#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("getppid");
entry(" int n;
    struct proc *p = myproc();  // Obtener el proceso actual

    // Obtener el valor del parámetro n
    if (argint(0, &n) < 0)
        return -1;  // Retornar -1 si el argumento es inválido

    // Caso base: n == 0 (el mismo proceso)
    if (n == 0)
        return p->pid;

    // Recorrer hacia arriba los ancestros
    for (int i = 0; i < n; i++) {
        if (p->parent == 0)  // Si no hay más ancestros (p es init o el kernel)
            return -1;
        p = p->parent;  // Moverse al proceso padre
    }

    return p->pid
